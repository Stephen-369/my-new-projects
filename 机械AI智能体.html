<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>机械设计AI助教原型 (本地版)</title>
    <style>
        /* 设置全局字体并确保页面居中 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8;
            padding: 1rem;
            margin: 0;
        }
        /* 隐藏滚动条但允许滚动 */
        textarea {
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        textarea::-webkit-scrollbar {
            display: none;
        }
        /* Canvas 样式 */
        canvas {
            background-color: #e0e7ff;
            border: 2px solid #a7b7ed;
            border-radius: 0.75rem;
            display: block;
            margin: 0 auto;
        }
        /* 主容器样式 */
        .container {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-width: 56rem;
            border: 1px solid #e2e8f0;
        }
        /* 标题样式 */
        .title {
            font-size: 1.875rem;
            font-weight: 700;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        /* 副标题样式 */
        .subtitle {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        /* 输入框样式 */
        .input-field {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            outline: none;
            transition: all 0.2s;
        }
        .input-field:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);
        }
        /* 标签样式 */
        .label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }
        /* 按钮基础样式 */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            outline: none;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .btn:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn:focus {
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }
        /* 不同颜色按钮 */
        .btn-green {
            background-color: #38a169;
            color: white;
        }
        .btn-green:hover {
            background-color: #2f855a;
        }
        .btn-purple {
            background-color: #805ad5;
            color: white;
        }
        .btn-purple:hover {
            background-color: #6b46c1;
        }
        .btn-red {
            background-color: #e53e3e;
            color: white;
        }
        .btn-red:hover {
            background-color: #c53030;
        }
        .btn-orange {
            background-color: #dd6b20;
            color: white;
        }
        .btn-orange:hover {
            background-color: #c05621;
        }
        .btn-indigo {
            background-color: #5a67d8;
            color: white;
        }
        .btn-indigo:hover {
            background-color: #4c51bf;
        }
        .btn-teal {
            background-color: #319795;
            color: white;
        }
        .btn-teal:hover {
            background-color: #2c7a7b;
        }
        .btn-blue {
            background-color: #3182ce;
            color: white;
        }
        .btn-blue:hover {
            background-color: #2b6cb0;
        }
        /* 网格布局 */
        .grid {
            display: grid;
            gap: 1rem;
        }
        .grid-cols-1 {
            grid-template-columns: repeat(1, minmax(0, 1fr));
        }
        .grid-cols-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }
        /* 响应式布局 */
        @media (min-width: 768px) {
            .md\:grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
            .md\:flex-row {
                flex-direction: row;
            }
        }
        /* 间距工具 */
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mb-6 {
            margin-bottom: 1.5rem;
        }
        .mt-4 {
            margin-top: 1rem;
        }
        .mt-6 {
            margin-top: 1.5rem;
        }
        .mr-2 {
            margin-right: 0.5rem;
        }
        .p-2 {
            padding: 0.5rem;
        }
        .p-3 {
            padding: 0.75rem;
        }
        .p-4 {
            padding: 1rem;
        }
        .p-8 {
            padding: 2rem;
        }
        /* 边框 */
        .border {
            border-width: 1px;
        }
        .border-b {
            border-bottom-width: 1px;
        }
        .border-gray-200 {
            border-color: #edf2f7;
        }
        /* 圆角 */
        .rounded-lg {
            border-radius: 0.5rem;
        }
        .rounded-xl {
            border-radius: 0.75rem;
        }
        /* 阴影 */
        .shadow-md {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        /* 文字样式 */
        .text-center {
            text-align: center;
        }
        .text-sm {
            font-size: 0.875rem;
        }
        .text-lg {
            font-size: 1.125rem;
        }
        .text-xl {
            font-size: 1.25rem;
        }
        .text-3xl {
            font-size: 1.875rem;
        }
        .font-semibold {
            font-weight: 600;
        }
        .font-bold {
            font-weight: 700;
        }
        .text-gray-700 {
            color: #4a5568;
        }
        .text-gray-800 {
            color: #2d3748;
        }
        .text-white {
            color: white;
        }
        /* 背景色 */
        .bg-white {
            background-color: white;
        }
        .bg-gray-50 {
            background-color: #f7fafc;
        }
        /* 其他工具类 */
        .flex {
            display: flex;
        }
        .flex-col {
            flex-direction: column;
        }
        .flex-1 {
            flex: 1 1 0%;
        }
        .items-center {
            align-items: center;
        }
        .justify-center {
            justify-content: center;
        }
        .w-full {
            width: 100%;
        }
        .h-auto {
            height: auto;
        }
        .min-h-\[100px\] {
            min-height: 100px;
        }
        .min-h-\[150px\] {
            min-height: 150px;
        }
        .max-w-2xl {
            max-width: 42rem;
        }
        .overflow-auto {
            overflow: auto;
        }
        .resize-y {
            resize: vertical;
        }
        .whitespace-pre-wrap {
            white-space: pre-wrap;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">机械设计AI助教原型 (本地版)</h1>

        <!-- 四杆机构参数输入区域 -->
        <div class="mb-6 border-b border-gray-200 pb-4">
            <h2 class="subtitle">四杆机构分析与仿真</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="l1-input" class="label">连杆 L₁ (输入曲柄):</label>
                    <input type="number" id="l1-input" class="input-field" placeholder="例如: 20" value="20">
                </div>
                <div>
                    <label for="l2-input" class="label">连杆 L₂ (连杆):</label>
                    <input type="number" id="l2-input" class="input-field" placeholder="例如: 50" value="50">
                </div>
                <div>
                    <label for="l3-input" class="label">连杆 L₃ (输出摇杆):</label>
                    <input type="number" id="l3-input" class="input-field" placeholder="例如: 40" value="40">
                </div>
                <div>
                    <label for="l4-input" class="label">连杆 L₄ (固定杆/机架):</label>
                    <input type="number" id="l4-input" class="input-field" placeholder="例如: 60" value="60">
                </div>
            </div>
            <div class="flex flex-col md:flex-row gap-4">
                <button id="analyze-fourbar-button" class="btn btn-green">
                    AI分析机构类型
                </button>
                <button id="start-simulation-button" class="btn btn-purple">
                    开始动态仿真
                </button>
                <button id="stop-simulation-button" class="btn btn-red">
                    停止仿真
                </button>
            </div>

            <!-- 仿真画布 -->
            <div class="mt-6">
                <canvas id="fourbar-canvas" class="w-full h-auto" width="600" height="400"></canvas>
            </div>
        </div>

        <!-- 凸轮机构分析区域 -->
        <div class="mb-6 border-b border-gray-200 pb-4 mt-6">
            <h2 class="subtitle">凸轮机构分析</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="cam-base-radius" class="label">基圆半径 (mm):</label>
                    <input type="number" id="cam-base-radius" class="input-field" placeholder="例如: 41" value="41">
                </div>
                <div>
                    <label for="cam-lift" class="label">升程 (mm):</label>
                    <input type="number" id="cam-lift" class="input-field" placeholder="例如: 18" value="18">
                </div>
                <div>
                    <label for="cam-push-angle" class="label">推程角度 (度):</label>
                    <input type="number" id="cam-push-angle" class="input-field" placeholder="例如: 270" value="270">
                </div>
                <div>
                    <label for="cam-return-angle" class="label">回程角度 (度):</label>
                    <input type="number" id="cam-return-angle" class="input-field" placeholder="例如: 90" value="90">
                </div>
                <div>
                    <label for="cam-roller-radius" class="label">滚子半径 (mm):</label>
                    <input type="number" id="cam-roller-radius" class="input-field" placeholder="例如: 5" value="5">
                </div>
                <div class="md:col-span-2">
                    <label for="cam-follower-type" class="label">从动件运动规律:</label>
                    <select id="cam-follower-type" class="input-field">
                        <option value="等速运动" selected>等速运动</option>
                        <option value="等加速等减速运动">等加速等减速运动</option>
                        <option value="简谐运动">简谐运动</option>
                    </select>
                </div>
            </div>
            <div class="flex flex-col md:flex-row gap-4">
                <button id="analyze-cam-button" class="btn btn-orange">
                    AI分析凸轮机构
                </button>
                <button id="draw-cam-button" class="btn btn-indigo">
                    绘制凸轮轮廓
                </button>
                <button id="start-cam-simulation-button" class="btn btn-purple">
                    开始凸轮仿真
                </button>
                <button id="stop-cam-simulation-button" class="btn btn-red">
                    停止凸轮仿真
                </button>
            </div>
            <!-- 凸轮仿真画布 -->
            <div class="mt-6">
                <canvas id="cam-canvas" class="w-full h-auto" width="400" height="400"></canvas>
            </div>
        </div>

        <!-- 传动装置分析区域 (以齿轮传动为例) -->
        <div class="mb-6 border-b border-gray-200 pb-4 mt-6">
            <h2 class="subtitle">传动装置分析 (齿轮传动)</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="gear-input-teeth" class="label">主动轮齿数 Z₁:</label>
                    <input type="number" id="gear-input-teeth" class="input-field" placeholder="例如: 20" value="20">
                </div>
                <div>
                    <label for="gear-output-teeth" class="label">从动轮齿数 Z₂:</label>
                    <input type="number" id="gear-output-teeth" class="input-field" placeholder="例如: 40" value="40">
                </div>
            </div>
            <button id="analyze-gear-button" class="btn btn-teal w-full">
                AI分析齿轮传动
            </button>
        </div>

        <!-- 通用问题输入区域 -->
        <div class="mb-4 mt-6">
            <h2 class="subtitle">通用问题</h2>
            <label for="user-input" class="label">
                请输入您的问题（例如：解释四杆机构的曲柄存在条件）:
            </label>
            <textarea id="user-input" class="input-field min-h-[100px]" placeholder="在这里输入您关于机械设计基础的任何问题..."></textarea>
        </div>

        <!-- 提交通用问题按钮 -->
        <button id="send-button" class="btn btn-blue w-full">
            提问
        </button>

        <!-- AI 回答显示区域 -->
        <div class="mt-6 p-4 bg-gray-50 border border-gray-200 rounded-lg min-h-[150px] overflow-auto">
            <h2 class="text-lg font-semibold text-gray-800 mb-2">AI助教的回答:</h2>
            <p id="ai-response" class="text-gray-700 whitespace-pre-wrap">
                智能体将在这里给出回答。
            </p>
        </div>
    </div>

    <script>
        // 获取页面元素 - 四杆机构
        const l1Input = document.getElementById('l1-input');
        const l2Input = document.getElementById('l2-input');
        const l3Input = document.getElementById('l3-input');
        const l4Input = document.getElementById('l4-input');
        const analyzeFourbarButton = document.getElementById('analyze-fourbar-button');
        const startSimulationButton = document.getElementById('start-simulation-button');
        const stopSimulationButton = document.getElementById('stop-simulation-button');

        // 获取页面元素 - 凸轮机构
        const camBaseRadiusInput = document.getElementById('cam-base-radius');
        const camLiftInput = document.getElementById('cam-lift');
        const camPushAngleInput = document.getElementById('cam-push-angle'); 
        const camReturnAngleInput = document.getElementById('cam-return-angle'); 
        const camRollerRadiusInput = document.getElementById('cam-roller-radius'); 
        const camFollowerTypeSelect = document.getElementById('cam-follower-type');
        const analyzeCamButton = document.getElementById('analyze-cam-button');
        const drawCamButton = document.getElementById('draw-cam-button'); 
        const startCamSimulationButton = document.getElementById('start-cam-simulation-button');
        const stopCamSimulationButton = document.getElementById('stop-cam-simulation-button');

        // 获取页面元素 - 传动装置
        const gearInputTeeth = document.getElementById('gear-input-teeth');
        const gearOutputTeeth = document.getElementById('gear-output-teeth');
        const analyzeGearButton = document.getElementById('analyze-gear-button');

        // 获取页面元素 - 通用
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const aiResponse = document.getElementById('ai-response');

        const fourbarCanvas = document.getElementById('fourbar-canvas');
        const fourbarCtx = fourbarCanvas.getContext('2d'); 

        const camCanvas = document.getElementById('cam-canvas'); 
        const camCtx = camCanvas.getContext('2d'); 

        // 全局变量用于四杆动画
        let fourbarAnimationFrameId = null;
        let fourbarCurrentAngle = 0; 
        const fourbarAngularSpeed = 0.05; 

        // 全局变量用于凸轮动画
        let camAnimationFrameId = null;
        let camCurrentAngle = 0;
        const camAngularSpeed = 0.03;
        let camProfilePoints = [];

        // 本地模拟AI响应
        const localAIResponses = {
            "四杆机构": [
                "根据格拉晓夫准则分析：",
                "1. 最短杆 + 最长杆 = 20 + 60 = 80",
                "2. 其他两杆之和 = 50 + 40 = 90",
                "因为80 < 90，满足格拉晓夫第一条件。",
                "且最短杆(20)为连架杆，所以这是一个曲柄摇杆机构。",
                "运动特性：输入曲柄可做整周转动，输出摇杆做往复摆动。"
            ].join("\n"),
            
            "凸轮机构": [
                "凸轮机构分析结果：",
                "1. 基圆半径: 41mm, 升程: 18mm",
                "2. 推程角度: 270°, 回程角度: 90°",
                "3. 从动件运动规律: 等速运动",
                "运动特性：",
                "- 推程阶段(0-270°): 从动件等速上升18mm",
                "- 回程阶段(270-360°): 从动件等速下降18mm",
                "- 压力角在推程开始和结束时较大，需校核是否超过许用值。"
            ].join("\n"),
            
            "齿轮传动": [
                "齿轮传动分析：",
                "1. 传动比 i = Z2/Z1 = 40/20 = 2",
                "2. 这是一个减速传动装置，传动比为2:1",
                "3. 转向关系：两齿轮转向相反",
                "4. 从动轮转速是主动轮的一半，扭矩是主动轮的2倍"
            ].join("\n"),
            
            "通用问题": [
                "关于四杆机构的曲柄存在条件：",
                "1. 格拉晓夫条件：最短杆与最长杆长度之和 ≤ 其他两杆长度之和",
                "2. 最短杆必须为连架杆或机架",
                "满足以上两个条件时：",
                "- 最短杆为连架杆 → 曲柄摇杆机构",
                "- 最短杆为机架 → 双曲柄机构",
                "- 不满足条件 → 双摇杆机构"
            ].join("\n")
        };

        // 模拟AI响应函数
        async function simulateAIResponse(promptType) {
            aiResponse.textContent = "思考中...";
            
            // 禁用所有按钮
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);
            
            // 模拟网络延迟
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // 根据问题类型返回不同的响应
            switch(promptType) {
                case "四杆机构":
                    aiResponse.textContent = localAIResponses["四杆机构"];
                    break;
                case "凸轮机构":
                    aiResponse.textContent = localAIResponses["凸轮机构"];
                    break;
                case "齿轮传动":
                    aiResponse.textContent = localAIResponses["齿轮传动"];
                    break;
                default:
                    aiResponse.textContent = localAIResponses["通用问题"];
            }
            
            // 重新启用所有按钮
            buttons.forEach(btn => btn.disabled = false);
        }

        // 绘制四杆机构的函数
        function drawFourBarMechanism(ctx, L1, L2, L3, L4, angle) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 

            const totalLength = L1 + L2 + L3 + L4;
            const scale = Math.min(ctx.canvas.width, ctx.canvas.height) / (totalLength * 0.8); 

            const originX = ctx.canvas.width / 2;
            const originY = ctx.canvas.height / 2;

            // 固定铰链 A 和 D 的坐标
            const Ax = originX - (L4 * scale) / 2;
            const Ay = originY; 

            const Dx = originX + (L4 * scale) / 2;
            const Dy = originY;

            // 动铰链 B 的坐标
            const Bx = Ax + L1 * scale * Math.cos(angle);
            const By = Ay + L1 * scale * Math.sin(angle);

            // 计算 B 到 D 的距离
            const distBD_sq = (Dx - Bx) * (Dx - Bx) + (Dy - By) * (Dy - By);
            const distBD = Math.sqrt(distBD_sq);

            // 检查机构是否能形成
            if (distBD > L2 * scale + L3 * scale || distBD < Math.abs(L2 * scale - L3 * scale)) {
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('机构无法形成或已变形！', originX, originY - 50);
                stopFourbarAnimation(); 
                return;
            }

            // 计算 C 点坐标
            const alpha = Math.acos((L3 * L3 * scale * scale + distBD_sq - L2 * L2 * scale * scale) / (2 * L3 * scale * distBD));
            const beta = Math.atan2(By - Dy, Bx - Dx);

            const Cx = Dx + L3 * scale * Math.cos(beta + alpha);
            const Cy = Dy + L3 * scale * Math.sin(beta + alpha);

            // 绘制连杆
            ctx.strokeStyle = '#4A90E2';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';

            // 固定杆 L4 (机架)
            ctx.beginPath();
            ctx.moveTo(Ax, Ay);
            ctx.lineTo(Dx, Dy);
            ctx.stroke();
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('机架 L4', (Ax + Dx) / 2, Ay + 20);

            // 输入曲柄 L1
            ctx.beginPath();
            ctx.moveTo(Ax, Ay);
            ctx.lineTo(Bx, By);
            ctx.stroke();
            ctx.fillText(`L1: ${L1}`, (Ax + Bx) / 2, (Ay + By) / 2 - 15);

            // 连杆 L2
            ctx.beginPath();
            ctx.moveTo(Bx, By);
            ctx.lineTo(Cx, Cy);
            ctx.stroke();
            ctx.fillText(`L2: ${L2}`, (Bx + Cx) / 2, (By + Cy) / 2 - 15);

            // 输出摇杆 L3
            ctx.beginPath();
            ctx.moveTo(Dx, Dy);
            ctx.lineTo(Cx, Cy);
            ctx.stroke();
            ctx.fillText(`L3: ${L3}`, (Dx + Cx) / 2, (Dy + Cy) / 2 - 15);

            // 绘制铰链
            ctx.fillStyle = '#FF6347';
            const jointRadius = 10;

            [Ax, Ay, Bx, By, Cx, Cy, Dx, Dy].forEach((coord, index) => {
                if (index % 2 === 0) {
                    ctx.beginPath(); 
                    ctx.arc(coord, arguments[index + 1], jointRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // 四杆动画循环函数
        function animateFourbar() {
            const L1 = parseFloat(l1Input.value);
            const L2 = parseFloat(l2Input.value);
            const L3 = parseFloat(l3Input.value);
            const L4 = parseFloat(l4Input.value);

            if (isNaN(L1) || isNaN(L2) || isNaN(L3) || isNaN(L4) || L1 <= 0 || L2 <= 0 || L3 <= 0 || L4 <= 0) {
                fourbarCtx.clearRect(0, 0, fourbarCanvas.width, fourbarCanvas.height);
                fourbarCtx.fillStyle = 'red';
                fourbarCtx.font = '16px Arial';
                fourbarCtx.textAlign = 'center';
                fourbarCtx.fillText('请输入有效的杆长（正数）进行仿真！', fourbarCanvas.width / 2, fourbarCanvas.height / 2);
                stopFourbarAnimation();
                return;
            }

            drawFourBarMechanism(fourbarCtx, L1, L2, L3, L4, fourbarCurrentAngle);

            fourbarCurrentAngle += fourbarAngularSpeed; 
            if (fourbarCurrentAngle > Math.PI * 2) { 
                fourbarCurrentAngle -= Math.PI * 2;
            }
            fourbarAnimationFrameId = requestAnimationFrame(animateFourbar); 
        }

        // 停止四杆动画的函数
        function stopFourbarAnimation() {
            if (fourbarAnimationFrameId) {
                cancelAnimationFrame(fourbarAnimationFrameId);
                fourbarAnimationFrameId = null;
                fourbarCtx.clearRect(0, 0, fourbarCanvas.width, fourbarCanvas.height);
                fourbarCtx.fillStyle = '#333';
                fourbarCtx.font = '16px Arial';
                fourbarCtx.textAlign = 'center';
                fourbarCtx.fillText('仿真已停止。', fourbarCanvas.width / 2, fourbarCanvas.height / 2);
            }
        }

        // 计算精确凸轮轮廓点的函数
        function calculateCamProfilePoints(baseRadius, lift, pushAngleDeg, returnAngleDeg, rollerRadius) {
            const points = [];
            const pushAngleRad = pushAngleDeg * Math.PI / 180;
            const returnAngleRad = returnAngleDeg * Math.PI / 180;
            const totalAngleCovered = pushAngleDeg + returnAngleDeg;

            const step = 0.5;

            for (let angleDeg = 0; angleDeg <= 360; angleDeg += step) {
                const camAngleRad = angleDeg * Math.PI / 180;
                let s = 0;
                let s_prime = 0;

                if (angleDeg >= 0 && angleDeg <= pushAngleDeg) {
                    s = lift * (camAngleRad / pushAngleRad);
                    s_prime = (pushAngleRad === 0) ? 0 : lift / pushAngleRad;
                } else if (angleDeg > pushAngleDeg && angleDeg <= totalAngleCovered) {
                    const angleInReturnPhaseRad = camAngleRad - pushAngleRad;
                    s = lift - lift * (angleInReturnPhaseRad / returnAngleRad);
                    s_prime = (returnAngleRad === 0) ? 0 : -lift / returnAngleRad;
                } else {
                    s = 0;
                    s_prime = 0;
                }

                const Rp = baseRadius + s;
                let alpha = 0;
                if (Rp !== 0) {
                    alpha = Math.atan2(s_prime, Rp);
                }
                
                const x_profile = Rp * Math.cos(camAngleRad) + rollerRadius * Math.sin(camAngleRad + alpha);
                const y_profile = Rp * Math.sin(camAngleRad) - rollerRadius * Math.cos(camAngleRad + alpha);

                points.push({ x: x_profile, y: y_profile });
            }
            return points;
        }

        // 根据预计算点绘制凸轮轮廓
        function drawCamProfileFromPoints(ctx, points, baseRadius, rollerRadius, scale, rotationAngle = 0) {
            if (points.length === 0) return;

            ctx.save();
            ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.rotate(rotationAngle);

            // 绘制凸轮轮廓
            ctx.beginPath();
            ctx.strokeStyle = '#00008B';
            ctx.lineWidth = 2 / scale;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = '#ADD8E6';
            ctx.fill();

            // 绘制基圆 (虚线)
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#808080';
            ctx.setLineDash([5 / scale, 5 / scale]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 绘制凸轮中心
            ctx.beginPath();
            ctx.arc(0, 0, 5 / scale, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();

            ctx.restore();
        }

        // 绘制从动件（滚子和杆）的函数
        function drawFollower(ctx, displacement, rollerRadius, scale, baseRadius) {
            ctx.save();
            ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
            ctx.scale(scale, scale);

            const rollerCenterX = 0;
            const rollerCenterY = -(baseRadius + displacement);

            // 绘制滚子
            ctx.beginPath();
            ctx.arc(rollerCenterX, rollerCenterY, rollerRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 / scale;
            ctx.stroke();

            // 绘制从动件杆
            const stemWidth = rollerRadius * 1.5;
            const stemBottomY = rollerCenterY - rollerRadius;
            const canvasTopYInScaledCoords = -(ctx.canvas.height / 2) / scale;
            const stemTopY = canvasTopYInScaledCoords;
            const stemHeight = stemBottomY - stemTopY;

            ctx.fillStyle = '#696969';
            ctx.fillRect(rollerCenterX - stemWidth / 2, stemTopY, stemWidth, stemHeight);

            ctx.restore();
        }

        // 计算凸轮相关图形的合适缩放比例
        function calculateCamScale(canvasWidth, canvasHeight, baseRadius, lift, rollerRadius) {
            const camMaxOuterRadius = baseRadius + lift + rollerRadius;
            const estimatedMaxFollowerVisualHeight = camMaxOuterRadius + baseRadius * 1.5;
            const maxDimensionNeeded = Math.max(2 * camMaxOuterRadius, estimatedMaxFollowerVisualHeight);
            const paddingFactor = 1.3;
            return Math.min(canvasWidth, canvasHeight) / (maxDimensionNeeded * paddingFactor);
        }

        // 凸轮动画循环函数
        function animateCam() {
            const baseRadius = parseFloat(camBaseRadiusInput.value);
            const lift = parseFloat(camLiftInput.value);
            const pushAngle = parseFloat(camPushAngleInput.value);
            const returnAngle = parseFloat(camReturnAngleInput.value);
            const rollerRadius = parseFloat(camRollerRadiusInput.value);

            if (isNaN(baseRadius) || isNaN(lift) || isNaN(pushAngle) || isNaN(returnAngle) || isNaN(rollerRadius) || 
                baseRadius <= 0 || lift < 0 || pushAngle < 0 || returnAngle < 0 || rollerRadius < 0) {
                camCtx.clearRect(0, 0, camCanvas.width, camCanvas.height);
                camCtx.fillStyle = 'red';
                camCtx.font = '16px Arial';
                camCtx.textAlign = 'center';
                camCtx.fillText('请输入有效的凸轮参数进行仿真！', camCanvas.width / 2, camCanvas.height / 2);
                stopCamAnimation();
                return;
            }

            // 计算当前凸轮角度下的从动件位移
            const angleDeg = (camCurrentAngle * 180 / Math.PI) % 360;
            let s = 0;

            if (angleDeg >= 0 && angleDeg <= pushAngle) {
                s = lift * (angleDeg / pushAngle);
            } else if (angleDeg > pushAngle && angleDeg <= (pushAngle + returnAngle)) {
                const angleInReturnPhase = angleDeg - pushAngle;
                s = lift - lift * (angleInReturnPhase / returnAngle);
                if (s < 0) s = 0;
            }

            const scale = calculateCamScale(camCanvas.width, camCanvas.height, baseRadius, lift, rollerRadius);
            camCtx.clearRect(0, 0, camCanvas.width, camCanvas.height);

            drawCamProfileFromPoints(camCtx, camProfilePoints, baseRadius, rollerRadius, scale, camCurrentAngle);
            drawFollower(camCtx, s, rollerRadius, scale, baseRadius);

            camCurrentAngle += camAngularSpeed;
            if (camCurrentAngle > Math.PI * 2) {
                camCurrentAngle -= Math.PI * 2;
            }
            camAnimationFrameId = requestAnimationFrame(animateCam);
        }

        // 停止凸轮动画
        function stopCamAnimation() {
            if (camAnimationFrameId) {
                cancelAnimationFrame(camAnimationFrameId);
                camAnimationFrameId = null;
                camCtx.clearRect(0, 0, camCanvas.width, camCanvas.height);
                camCtx.fillStyle = '#333';
                camCtx.font = '16px Arial';
                camCtx.textAlign = 'center';
                camCtx.fillText('凸轮仿真已停止。', camCanvas.width / 2, camCanvas.height / 2);
            }
        }

        // 绑定事件监听器 - 通用提问
        sendButton.addEventListener('click', () => {
            stopFourbarAnimation();
            stopCamAnimation();
            const prompt = userInput.value.trim();
            if (!prompt) {
                aiResponse.textContent = '请输入您的问题。';
                return;
            }
            simulateAIResponse("通用问题");
        });

        // 绑定事件监听器 - 四杆机构分析
        analyzeFourbarButton.addEventListener('click', () => {
            stopFourbarAnimation();
            stopCamAnimation();
            const l1 = parseFloat(l1Input.value);
            const l2 = parseFloat(l2Input.value);
            const l3 = parseFloat(l3Input.value);
            const l4 = parseFloat(l4Input.value);

            if (isNaN(l1) || isNaN(l2) || isNaN(l3) || isNaN(l4) || l1 <= 0 || l2 <= 0 || l3 <= 0 || l4 <= 0) {
                aiResponse.textContent = '请输入有效的杆长（正数）。';
                return;
            }

            simulateAIResponse("四杆机构");
        });

        // 绑定事件监听器 - 开始四杆仿真
        startSimulationButton.addEventListener('click', () => {
            const L1 = parseFloat(l1Input.value);
            const L2 = parseFloat(l2Input.value);
            const L3 = parseFloat(l3Input.value);
            const L4 = parseFloat(l4Input.value);

            if (isNaN(L1) || isNaN(L2) || isNaN(L3) || isNaN(L4) || L1 <= 0 || L2 <= 0 || L3 <= 0 || L4 <= 0) {
                aiResponse.textContent = '请先输入有效的杆长（正数）才能开始仿真。';
                return;
            }

            stopFourbarAnimation();
            stopCamAnimation();
            fourbarCurrentAngle = 0;
            animateFourbar();
        });

        // 绑定事件监听器 - 停止四杆仿真
        stopSimulationButton.addEventListener('click', () => {
            stopFourbarAnimation();
        });

        // 绑定事件监听器 - 凸轮机构AI分析
        analyzeCamButton.addEventListener('click', () => {
            stopFourbarAnimation();
            stopCamAnimation();
            const baseRadius = parseFloat(camBaseRadiusInput.value);
            const lift = parseFloat(camLiftInput.value);
            const pushAngle = parseFloat(camPushAngleInput.value);
            const returnAngle = parseFloat(camReturnAngleInput.value);
            const rollerRadius = parseFloat(camRollerRadiusInput.value);

            if (isNaN(baseRadius) || isNaN(lift) || isNaN(pushAngle) || isNaN(returnAngle) || isNaN(rollerRadius) || 
               baseRadius <= 0 || lift < 0 || pushAngle < 0 || returnAngle < 0 || rollerRadius < 0) {
                aiResponse.textContent = '请输入有效的凸轮机构参数（基圆半径、升程、角度和滚子半径需为非负数，基圆半径需大于0）。';
                return;
            }
            if (pushAngle + returnAngle > 360) {
                aiResponse.textContent = '推程角度和回程角度之和不能超过360度。';
                return;
            }

            simulateAIResponse("凸轮机构");
        });

        // 绑定事件监听器 - 绘制凸轮轮廓 (静态绘制)
        drawCamButton.addEventListener('click', () => {
            stopFourbarAnimation();
            stopCamAnimation();
            const baseRadius = parseFloat(camBaseRadiusInput.value);
            const lift = parseFloat(camLiftInput.value);
            const pushAngle = parseFloat(camPushAngleInput.value);
            const returnAngle = parseFloat(camReturnAngleInput.value);
            const rollerRadius = parseFloat(camRollerRadiusInput.value);

            if (isNaN(baseRadius) || isNaN(lift) || isNaN(pushAngle) || isNaN(returnAngle) || isNaN(rollerRadius) || 
               baseRadius <= 0 || lift < 0 || pushAngle < 0 || returnAngle < 0 || rollerRadius < 0) {
                aiResponse.textContent = '绘制凸轮请确保所有参数为有效正数（基圆半径需大于0）。';
                return;
            }
            if (pushAngle + returnAngle > 360) {
                aiResponse.textContent = '推程角度和回程角度之和不能超过360度。';
                return;
            }

            camProfilePoints = calculateCamProfilePoints(baseRadius, lift, pushAngle, returnAngle, rollerRadius);
            const scale = calculateCamScale(camCanvas.width, camCanvas.height, baseRadius, lift, rollerRadius);
            
            camCtx.clearRect(0, 0, camCanvas.width, camCanvas.height);
            drawCamProfileFromPoints(camCtx, camProfilePoints, baseRadius, rollerRadius, scale, 0);
            drawFollower(camCtx, 0, rollerRadius, scale, baseRadius);
            
            aiResponse.textContent = '凸轮轮廓已绘制完成。注意：当前绘制假设为径向滚子从动件，并严格按照等速推程和回程角度进行。';
        });

        // 绑定事件监听器 - 开始凸轮仿真
        startCamSimulationButton.addEventListener('click', () => {
            const baseRadius = parseFloat(camBaseRadiusInput.value);
            const lift = parseFloat(camLiftInput.value);
            const pushAngle = parseFloat(camPushAngleInput.value);
            const returnAngle = parseFloat(camReturnAngleInput.value);
            const rollerRadius = parseFloat(camRollerRadiusInput.value);

            if (isNaN(baseRadius) || isNaN(lift) || isNaN(pushAngle) || isNaN(returnAngle) || isNaN(rollerRadius) || 
               baseRadius <= 0 || lift < 0 || pushAngle < 0 || returnAngle < 0 || rollerRadius < 0) {
                aiResponse.textContent = '请先输入有效的凸轮参数才能开始仿真。';
                return;
            }

            stopFourbarAnimation();
            stopCamAnimation();
            camProfilePoints = calculateCamProfilePoints(baseRadius, lift, pushAngle, returnAngle, rollerRadius);
            camCurrentAngle = 0;
            animateCam();
        });

        // 绑定事件监听器 - 停止凸轮仿真
        stopCamSimulationButton.addEventListener('click', () => {
            stopCamAnimation();
        });

        // 绑定事件监听器 - 齿轮传动分析
        analyzeGearButton.addEventListener('click', () => {
            stopFourbarAnimation();
            stopCamAnimation();
            const inputTeeth = parseFloat(gearInputTeeth.value);
            const outputTeeth = parseFloat(gearOutputTeeth.value);

            if (isNaN(inputTeeth) || isNaN(outputTeeth) || inputTeeth <= 0 || outputTeeth <= 0) {
                aiResponse.textContent = '请输入有效的齿数（正整数）。';
                return;
            }

            simulateAIResponse("齿轮传动");
        });

        // Canvas 初始设置和响应式调整 (四杆)
        function resizeFourbarCanvas() {
            fourbarCanvas.width = fourbarCanvas.parentElement.clientWidth;
            fourbarCanvas.height = Math.min(400, fourbarCanvas.width * 0.75);
            if (!fourbarAnimationFrameId) {
                fourbarCtx.clearRect(0, 0, fourbarCanvas.width, fourbarCanvas.height);
                fourbarCtx.fillStyle = '#333';
                fourbarCtx.font = '16px Arial';
                fourbarCtx.textAlign = 'center';
                fourbarCtx.fillText('输入杆长并点击"开始动态仿真"', fourbarCanvas.width / 2, fourbarCanvas.height / 2);
                fourbarCtx.fillText('或"AI分析机构类型"', fourbarCanvas.width / 2, fourbarCanvas.height / 2 + 25);
            }
        }

        // Canvas 初始设置和响应式调整 (凸轮)
        function resizeCamCanvas() {
            camCanvas.width = camCanvas.parentElement.clientWidth;
            camCanvas.height = Math.min(400, camCanvas.width);
            
            camCtx.clearRect(0, 0, camCanvas.width, camCanvas.height);
            camCtx.fillStyle = '#333';
            camCtx.font = '16px Arial';
            camCtx.textAlign = 'center';
            camCtx.fillText('输入凸轮参数并点击"绘制凸轮轮廓"', camCanvas.width / 2, camCanvas.height / 2);
            camCtx.fillText('或"开始凸轮仿真"', camCanvas.width / 2, camCanvas.height / 2 + 25);
        }

        // 窗口大小改变时调整画布
        window.addEventListener('resize', () => {
            resizeFourbarCanvas();
            resizeCamCanvas();
        });

        // 页面加载时初始化
        window.addEventListener('load', () => {
            resizeFourbarCanvas();
            resizeCamCanvas();
        });
    </script>
</body>
</html>